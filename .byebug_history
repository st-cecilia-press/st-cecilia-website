continue
individual_pieces
individual_piece
@piece
piece
exit
individual_pieces.piece
individual_pieces.pieces
individual_pieces.piece
continue
individual_pieces.editions(
individual_pieces.editions
individual_pieces
individual_piece
continue
editions.second[:parts]
editions.first[:parts]
editions[:parts]
editions
continue
editions
continue
editions
continue
my_editions
continue
directory
piece.slug
piece
continue
@compilations["original"]
exit
@compilations.first['original']
@compilations.first
@compilations["original"]
@compilations["modern"]
@compilations
@comilations
continue
@compilations
continue
next
continue
editions
next
continue
exit
editions
next
@piece
continue
next
@piece.repo
@piece
continue
exit
continue
@piece
continue
@piece
continue
@piece.first
@piece
continue
@piece
@pieces
continue
next
@pieces
continue
@pieces
exit
v.each.map{|voice| puts voice.pieces if voice.name.length 
Voicing.all.each.map{|voice| puts voice.pieces if voice.name.length == 4}.uniq.compact
Voicing.all.each.map{|voice| puts voice.pieces if voice.name.length == 4}.uniq
@pieces.first.title
@pieces.first
@pieces
continue
@pieces
continue
next
continue
voicing.pieces
next
continue
@pieces
next
v
next
num
next
continue
params[:voicing].to_i
num
next
continue
Voicing.all.each.map{|voice| puts voice.name if voice.name.length == 4}.uniq
Voicing.all.each.map{|voice| puts voice if voice.name.length == 4}.uniq
Voicing.all.each.map{|voice| puts voice if voice.name == 4}.uniq
Voicing.all
Voicing.all.each.map{|voice| voice.pieces if voice.name == 4}.uniq
Voicing.find_by(name: params[:voicing]).pieces
Voicing.find_by(name: params[:voicing])
params[:voicing]
@pieces
continue
@pieces
@piece
continue
exit
continue
next
continue
response.body
next
continue
next
p.voicings
p = Piece.find_by(repo: params[:repo], slug: params[:slug])
params
continue
next
@piece.voicings
@piece.voicing
continue
next
@piece.voicings
@piece
continue
next
piece.voicings
piece
continue
exit
Voicing.first
Voicing.all
@piece
continue
@piece.voicings
continue
@piece.voicings
@piece
exit
response.body
exit
@composers.first
@composer.first
@composer
composer
continue
response
continue
response.should respond_to
respond_to
response
email
continue
response
body
response.body
continue
next
email.subject
continue
subject
email.subject
email
continue
edition[:parts]
edition
continue
piece.composer.name
piece
continue
params[:repo]
params[:repo].exists?
params[:slug]
params[:repo]
continue
params[:repo]
continue
params[:repo]
continue
params[:repo]
params[:repo
params[:slug]
params[:repo].exists?
params[:repo]
params[:repo
continue
my_parts
next
numbers[num]
next
numbers
nubmers
continue
numbers
num
numbers[num]
num
next
continue
contineu
line.scan(/scMusic(\w+)Name/)[0][0]
line.scan(/scMusic(\w+)Name/)[0]
num
next
line
continue
line
continue
line
next
line
continue
lily_file
`cat #{lily_file}`
`cat lily_file`
cat lily_file
f
continue
f
continue
my_parts
next
lily_file
continue
path.to_s
path
puts path
path
next
Rails.public_path.join("repo/slug")
Rails.public_path
Rails
continue
response.body
continue
Date.new(1500)
Date.new('1500')
Date.new('1500'
@book
continue
link_to "#{piece.title}", piece_path(piece.repo, piece.slug)
piece.title
continue
link_to "piece", piece_path(piece.repo, piece.slug)
link_to "piece", piece_path(piece, piece.repo, piece.slug)
link_to "piece", show_piece_path(piece, piece.repo, piece.slug)
url_for 
url_for piece
piece
continue
next
